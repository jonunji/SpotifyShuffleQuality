<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Shuffle Analyzer</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>

<body>
    <div id="instructionModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Welcome to Spotify Shuffle Analyzer!</h2>
            <p>The tool works by constantly reshuffling your active queue and recording the data.</p>
            <p>To get the most accurate information, please follow these instructions:</p>
            <ul>
                <li><strong>Play Something:</strong> You may need to play something to initiate tracking. After tracking
                    has started, you can pause or continue your media.</li>
                <li><strong>Keep Spotify open:</strong> Ensure Spotify is open on a connected
                    device. This is needed for continuous calls to Spotify's servers.</li>
                <li><strong>Clear Your Queue:</strong> Checks are made to determine if the list has been shuffled. Songs
                    in the queue do not change, so this disrupts that check.</li>
                <li><strong>Play inside a playlist/album:</strong> To see statistics about a specific playlist or album
                    you're interested in, make sure to play music from where you're interested.</li>
            </ul>
            <p>We'll then analyze how songs are added to your queue.</p>
            <button id="modal-understood-button" class="btn">Understood!</button>
        </div>
    </div>
    <div id="shuffleOrderModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeShuffleOrderModal">&times;</span>
            <h2 id="shuffleOrderModalTitle">Shuffle Order</h2>

            <div id="shuffleOrderMultiContainer" class="shuffle-order-comparison-container"></div>

            <p id="shuffleOrderError" style="color: var(--error-color); text-align: center; display: none;"></p>
        </div>
    </div>


    <div class="main-wrapper">
        <h1>Spotify Shuffle Analyzer</h1>

        <div class="nav-links">
            {% if logged_in %}
            <a href="/reset" class="nav-link">Reset Data</a>
            <a href="#" id="help-button" class="nav-link">Help</a>
            <a href="/logout" class="nav-link">Logout</a>
            {% endif %}
        </div>

        {% if logged_in %}
        <div id="status-container" class="status status-inactive">
            <p id="status-text">
                Queue tracking is <strong>inactive</strong>. Click the button below to start tracking.
            </p>
        </div>

        <button id="toggle-tracking" class="btn {% if not running %}btn-inactive{% endif %}">
            {% if running %}
            Stop Tracking
            {% else %}
            Start Tracking
            {% endif %}
        </button>

        <div class="stats-grid">
            <div class="stat-box">
                <h3>Current Playback</h3>
                <p>Song: <span id="playback-item-name" class="stat-value">N/A</span></p>
                <p>Artist: <span id="playback-item-artist" class="stat-value">N/A</span></p>
            </div>
            <div id="tracking-summary-box" class="stat-box">
                <h3>Tracking Summary</h3>
                <p>Unique Tracks Tracked: <span id="total-unique-tracks" class="stat-value">0</span></p>
                <p>Total Plays Counted: <span id="total-plays-counted" class="stat-value">0</span></p>
                <p>Number of Tracks Displayed: <span id="total-tracks-shown" class="stat-value">0</span></p>
            </div>
            <div class="stat-box" style="grid-column: 1 / -1;">
                <h3>Current Context (<span id="context-type" class="stat-value">Unknown</span>)</h3>
                <div id="context-display" class="context-display">
                    <img id="context-image" class="context-image" src="" alt="Context Image">
                    <div class="context-details">
                        <h3 id="context-name">N/A</h3>
                        <p id="context-owner-total"></p>
                    </div>
                </div>
                <p id="no-context-message" style="display: none;">No active context found or playing item is not from a
                    known context (e.g., local file, individual track).</p>
            </div>
            <div class="stat-box" style="grid-column: 1 / -1;">
                <h3>Tracks with Patterns</h3>
                <div style="flex-direction: column; align-items: flex-start;">
                    <ul id="all-patterns-list" class="stat-list">
                        {% if initial_queue_data and initial_queue_data.tracks_with_patterns %}
                        {% for track in initial_queue_data.tracks_with_patterns %}
                        <li class="track-item">
                            <strong>{{ track.name }}</strong> - {{ track.artists | map(attribute='name') | join(', ') }}
                        </li>
                        {% endfor %}
                        {% else %}
                        <li>No patterns found yet. Start tracking to see patterns.</li>
                        {% endif %}
                    </ul>
                </div>
            </div>
        </div>

        <div id="queue-data" class="container">
            <h2>Your Most Played Tracks in Queue</h2>
            <div class="search-and-pagination-controls">
                <input type="text" id="track-search-input" placeholder="Search by song or artist name" disabled>
                <div class="pagination-controls">
                    <button id="prev-page-btn" disabled>&laquo; Prev</button>
                    <span id="page-info">Page 1</span>
                    <button id="next-page-btn" disabled>Next &raquo;</button>
                </div>
            </div>
            <ul class="track-list" id="track-list-container">
            </ul>
            <div class="no-tracks" id="no-tracks-message" style="display: none;">
                <p>No track data collected yet. Make sure tracking is enabled and you're using Spotify.</p>
            </div>
        </div>
        {% else %}
        <div class="container" style="text-align: center;">
            <p>Please login with your Spotify account to start tracking your queue.</p>
            <a href="/login" class="btn">Login with Spotify</a>
        </div>
        {% endif %}
    </div>

    <script>
        // Only execute if logged in
        {% if logged_in %}

        let isTracking = {{ running| tojson }};
        let isInitializing = false;
        let currentPage = 0;
        const tracksPerPage = 50; // Default for non-tracking mode
        let currentSearchQuery = '';
        let hasMoreTracks = false;

        const toggleButton = document.getElementById('toggle-tracking');
        const statusContainer = document.getElementById('status-container');
        const statusText = document.getElementById('status-text');
        const trackListContainer = document.getElementById('track-list-container');
        const noTracksMessage = document.getElementById('no-tracks-message');

        // Playback Info Elements
        const playbackItemName = document.getElementById('playback-item-name');
        const playbackItemArtist = document.getElementById('playback-item-artist');

        const totalUniqueTracks = document.getElementById('total-unique-tracks');
        const totalPlaysCounted = document.getElementById('total-plays-counted');
        const totalTracksShown = document.getElementById('total-tracks-shown');
        const trackingSummaryBox = document.getElementById('tracking-summary-box');

        // Context Info Elements
        const contextType = document.getElementById('context-type');
        const contextDisplay = document.getElementById('context-display');
        const contextImage = document.getElementById('context-image');
        const contextName = document.getElementById('context-name');
        const contextOwnerTotal = document.getElementById('context-owner-total');
        const noContextMessage = document.getElementById('no-context-message');

        // All patterns list
        const allPatternsList = document.getElementById('all-patterns-list');

        // Modal elements
        const instructionModal = document.getElementById('instructionModal');
        const closeButton = document.querySelector('.close-button');
        const modalUnderstoodButton = document.getElementById('modal-understood-button');
        const helpButton = document.getElementById('help-button');

        // shuffle order modal
        const shuffleOrderModal = document.getElementById('shuffleOrderModal');
        const shuffleOrderModalTitle = document.getElementById('shuffleOrderModalTitle');
        const shuffleOrderMultiContainer = document.getElementById('shuffleOrderMultiContainer');
        const shuffleOrderError = document.getElementById('shuffleOrderError');

        // Pagination and Search elements
        const trackSearchInput = document.getElementById('track-search-input');
        const prevPageBtn = document.getElementById('prev-page-btn');
        const nextPageBtn = document.getElementById('next-page-btn');
        const pageInfo = document.getElementById('page-info');

        function updatePaginationControls(resetControls = false) {
            if (isTracking) {
                // Disable all pagination controls when tracking is active
                trackSearchInput.disabled = true;
                prevPageBtn.disabled = true;
                nextPageBtn.disabled = true;
                pageInfo.textContent = `Page 1 (Top ${tracksPerPage})`;
            } else {
                trackSearchInput.disabled = false;
                prevPageBtn.disabled = currentPage === 0;
                nextPageBtn.disabled = !hasMoreTracks;
                pageInfo.textContent = `Page ${currentPage + 1} / ${Math.ceil(totalUniqueTracks.textContent / tracksPerPage)}`;
            }

            if (resetControls) {
                currentPage = 0; // Reset pagination when tracking starts
                currentSearchQuery = '';
                trackSearchInput.value = ''; // Clear search input
            }
        }

        function updateAllPatternsList(tracksWithPatterns) {

            allPatternsList.innerHTML = '';

            if (tracksWithPatterns && tracksWithPatterns.length > 0) {
                // Use map to create an array of HTML strings for each track
                allPatternsList.innerHTML = tracksWithPatterns.map(track => {
                    const artists = track.artists.map(a => a.name).join(', ');
                    return `
                    <li class="track-item">
                        <strong>${track.name}</strong> ${artists}
                    </li>
                `;
                }).join(''); // Join all HTML strings into one single string

            } else {
                allPatternsList.innerHTML = '<li>No patterns found yet.</li>';
            }
        }

        function renderTracks(tracks) {
            trackListContainer.innerHTML = '';
            if (tracks && tracks.length > 0) {
                noTracksMessage.style.display = 'none';
                tracks.forEach(track => {
                    const trackItem = document.createElement('li');
                    trackItem.classList.add('track-item');
                    trackItem.dataset.trackId = track.id;

                    const imageUrl = track.album && track.album.images && track.album.images.length > 0
                        ? track.album.images[0].url
                        : '';
                    const artists = track.artists.map(a => a.name).join(', ') || 'Unknown Artist';

                    trackItem.innerHTML = `
                        <div class="track-main-info">
                            ${imageUrl ? `<img class="track-image" src="${imageUrl}" alt="${track.name} album art">` : '<div class="track-image"></div>'}
                            <div class="track-info">
                                <div class="track-name">${track.name}</div>
                                <div class="track-artist">${artists}</div>
                            </div>
                            <div class="track-frequency">${track.frequency}</div>
                        </div>
                        <div class="track-details-dropdown" style="display: none;">
                            </div>
                    `;
                    trackListContainer.appendChild(trackItem);
                });

                trackListContainer.querySelectorAll('.track-item').forEach(item => {
                    item.addEventListener('click', handleTrackClick);
                });

            } else {
                noTracksMessage.style.display = 'block';
                noTracksMessage.querySelector('p').textContent = "No track data collected yet. Make sure tracking is enabled and you're using Spotify.";
            }
        }

        async function handleTrackClick(event) {
            // Prevent closing if click is inside an already open dropdown
            if (event.target.closest('.track-details-dropdown') && event.currentTarget.classList.contains('active')) {
                return;
            }

            if (isTracking) {
                alert("Please stop tracking before clicking on individual songs for stats.");
                return;
            }

            const clickedTrackItem = event.currentTarget;
            const trackId = clickedTrackItem.dataset.trackId;
            const trackDetailsDropdown = clickedTrackItem.querySelector('.track-details-dropdown');

            if (!trackId || !trackDetailsDropdown) {
                console.error("No track ID or dropdown found for clicked item.");
                return;
            }

            // Close other open dropdowns
            document.querySelectorAll('.track-details-dropdown').forEach(dropdown => {
                if (dropdown !== trackDetailsDropdown && dropdown.style.display !== 'none') {
                    dropdown.style.display = 'none';
                    dropdown.closest('.track-item').classList.remove('active');
                    dropdown.innerHTML = '';
                }
            });

            // Toggle the clicked track's dropdown
            if (trackDetailsDropdown.style.display === 'none') {
                trackDetailsDropdown.style.display = 'block';
                clickedTrackItem.classList.add('active');

                trackDetailsDropdown.innerHTML = `<div style="text-align: center; color: var(--text-color-secondary); padding: 10px;">Loading stats...</div>`;

                try {
                    const response = await fetch(`/track_stats/${trackId}`);
                    const data = await response.json();

                    if (data.status === 'error') {
                        trackDetailsDropdown.innerHTML = `<div style="color: var(--error-color); padding: 10px;">Error: ${data.error}</div>`;
                        console.error("Error fetching track stats:", data.error);
                    } else {
                        updateIndividualTrackStats(data, trackDetailsDropdown, trackId);
                    }
                } catch (error) {
                    console.error('Error fetching individual track stats:', error);
                    trackDetailsDropdown.innerHTML = `<div style="color: var(--error-color); padding: 10px;">Network error loading stats.</div>`;
                }
            } else {
                trackDetailsDropdown.style.display = 'none';
                clickedTrackItem.classList.remove('active');
                trackDetailsDropdown.innerHTML = '';
            }
        }

        function formatGroupedTracksByArtist(groupedData, getArtistId, getArtistName) {
            return Object.keys(groupedData).map(artistId => {
                const tracksForArtist = groupedData[artistId];

                if (!Array.isArray(tracksForArtist) || tracksForArtist.length === 0) return '';

                const artistName = getArtistName(tracksForArtist, artistId) || 'Unknown Artist';

                const trackItems = tracksForArtist.map(track => {
                    return `<li>${track.name} (${track.frequency} plays)</li>`;
                }).join('');

                return `
                    <li>
                        <strong>${artistName}</strong> (${tracksForArtist.length} track${tracksForArtist.length !== 1 ? 's' : ''}):
                        <ul class="nested-stat-list">
                            ${trackItems}
                        </ul>
                    </li>
                `;
            }).join('');
        }

        function formatStatBlock(title, listHtml) {
            return `
                <div class="stat-row" style="flex-direction: column; align-items: flex-start;">
                    <span class="stat-label" style="margin-bottom: 5px;">${title}</span>
                    <ul class="stat-list">
                        ${listHtml}
                    </ul>
                </div>`;
        }

        function updateIndividualTrackStats(stats, dropdownElement, selected_track_id) {
            const artists = stats.artists.map(a => a.name).join(', ') || 'N/A';
            const durationMinutes = Math.floor(stats.duration_ms / 60000);
            const seconds = ((stats.duration_ms % 60000) / 1000).toFixed(0);
            const formattedDuration = `${durationMinutes}:${(seconds < 10 ? '0' : '')}${seconds}`;
            const genres = stats.artist_genres && stats.artist_genres.length > 0 ? stats.artist_genres.join(', ') : 'N/A';
            const shuffleChance = stats.shuffle_chance_percent ? stats.shuffle_chance_percent.toFixed(2) : '0.00';
            const popularity = stats.popularity || 0;

            let artistBreakdownHtml = '';
            if (typeof stats.songs_by_same_artists === 'object' && Object.keys(stats.songs_by_same_artists).length > 0) {
                const artistListItems = formatGroupedTracksByArtist(
                    stats.songs_by_same_artists,
                    // Get artistId directly
                    (tracks, id) => id,
                    // Get artist name from the track's artist array
                    (tracks, id) => tracks[0].artists.find(a => String(a.id) === String(id))?.name
                );

                artistBreakdownHtml = formatStatBlock('Breakdown by Matching Artists:', artistListItems);
            } else {
                artistBreakdownHtml = `
                    <div class="stat-row">
                        <span class="stat-label">Songs by Matching Artists:</span>
                        <span class="stat-value">0</span>
                    </div>`;
            }

            let genreMatchHtml = '';
            if (Array.isArray(stats.songs_matching_genre) && stats.songs_matching_genre.length > 0) {
                // First, group by artist name
                const genreGroupedByArtist = {};
                for (const track of stats.songs_matching_genre) {
                    for (const artist of track.artists) {
                        const artistName = artist.name || 'Unknown Artist';
                        if (!genreGroupedByArtist[artistName]) genreGroupedByArtist[artistName] = [];
                        genreGroupedByArtist[artistName].push(track);
                    }
                }

                const genreListItems = formatGroupedTracksByArtist(
                    genreGroupedByArtist,
                    (tracks, artistName) => artistName,
                    (tracks, artistName) => artistName
                );

                genreMatchHtml = formatStatBlock('Songs Matching Genres:', genreListItems);
            } else {
                genreMatchHtml = `
                    <div class="stat-row">
                        <span class="stat-label">Songs Matching Genres:</span>
                        <span class="stat-value">0</span>
                    </div>`;
            }

            let patternsHtml = '';
            if (stats.patterns && stats.patterns.length > 0) {
                const uniquePatternsWithCounts = stats.patterns;

                const patternColumnsHtml = uniquePatternsWithCounts.map((patternData, index) => {
                    const patternTracks = patternData.pattern;
                    const patternCount = patternData.count;

                    if (!Array.isArray(patternTracks) || patternTracks.length < 2) {
                        return '';
                    }

                    const trackListItems = patternTracks.map(track_obj => {
                        // Crucial for bolding: Ensure comparison is robust
                        const isSelectedTrackInPattern = String(track_obj.id) === String(selected_track_id);
                        const classAttr = isSelectedTrackInPattern ? ' class="highlight-track"' : '';
                        return `<li${classAttr}>${track_obj.name}</li>`;
                    }).join('');

                    return `
                        <div class="pattern-column">
                            <h4>Pattern ${index + 1} <span style="font-size: 0.8em; color: var(--text-color-secondary);">(${patternCount} time${patternCount !== 1 ? 's' : ''})</span></h4>
                            <ul>
                                ${trackListItems}
                            </ul>
                        </div>
                    `;
                }).filter(Boolean).join('');

                patternsHtml = `
                    <div class="stat-row" style="flex-direction: column; align-items: flex-start; margin-top: 15px;">
                        <span class="stat-label" style="margin-bottom: 5px;">Unique Shuffle Patterns Found:</span>
                        <div class="pattern-container">
                            ${patternColumnsHtml}
                        </div>
                    </div>`;
            } else {
                patternsHtml = `
                    <div class="stat-row" style="margin-top: 15px;">
                        <span class="stat-label">Unique Shuffle Patterns Found:</span>
                        <span class="stat-value">None</span>
                    </div>`;
            }

            let shuffleSelectOptions = stats.shuffle_ids.map(id => `<option value="${id}">${id}</option>`).join('');

            shuffleOrderHtml = `
                    <span class="stat-label" style="margin-bottom: 5px;">Relevant Shuffle Queues:</span>
                    <div class="shuffle-control-row"">
                        <select class="shuffle-id-multiselect" id="shuffleMultiSelect-${stats.id}" multiple size="4">
                            ${shuffleSelectOptions}
                        </select>
                        <button class="view-order-btn" disabled style="height: fit-content;">View Shuffle Order</button>
                    </div>
            `;

            dropdownElement.innerHTML = `
                <div class="track-details-content">
                    <div class="stat-row">
                        <span class="stat-label">Plays in Queue:</span>
                        <span class="stat-value">${stats.frequency}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Approx. Shuffle Chance:</span>
                        <span class="stat-value">${shuffleChance}%</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Album:</span>
                        <span class="stat-value">${stats.album_name}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Duration:</span>
                        <span class="stat-value">${formattedDuration}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Popularity:</span>
                        <span class="stat-value">${popularity}%</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Genres (of artists):</span>
                        <span class="stat-value">${genres}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Total Plays by Matching Artists:</span>
                        <span class="stat-value">${stats.total_plays_by_same_artists}</span>
                    </div>
                    ${artistBreakdownHtml}
                    ${genreMatchHtml}
                    ${patternsHtml}
                    ${shuffleOrderHtml}
                </div>
            `;

            // Attach listener to multi-select and view button
            const multiSelect = dropdownElement.querySelector(`#shuffleMultiSelect-${stats.id}`);
            const viewBtn = dropdownElement.querySelector('.view-order-btn');

            // Update the view button when selection changes
            function updateMultiSelectButton() {
                const selectedOptions = Array.from(multiSelect.selectedOptions).map(opt => opt.value);

                viewBtn.dataset.shuffleIds = JSON.stringify(selectedOptions);
                viewBtn.dataset.trackId = selected_track_id;

                viewBtn.disabled = selectedOptions.length === 0; // Disable if nothing is selected
            }

            multiSelect.addEventListener('change', updateMultiSelectButton);
            updateMultiSelectButton(); // initialize state

            // Handle button click
            viewBtn.addEventListener('click', (e) => {
                const shuffleIds = JSON.parse(e.currentTarget.dataset.shuffleIds);
                const selectedTrackId = e.currentTarget.dataset.trackId;

                handleCompareMultipleShuffles(shuffleIds, selectedTrackId);  // send full list
            });
        }

        function createShuffleOrderContainer(shuffleId, selectedTrackId, shuffleOrder) {
            const container = document.createElement('div');
            container.classList.add('shuffle-order-column');

            const titleEl = document.createElement('h3');
            titleEl.textContent = `Shuffle ID: ${shuffleId}`;
            container.appendChild(titleEl);

            const ul = document.createElement('ul');
            ul.classList.add('shuffle-order-list');

            if (shuffleOrder?.length > 0) {
                shuffleOrder.forEach(track => {
                    const li = document.createElement('li');
                    li.textContent = `${track.name} - ${track.artists.map(a => a.name).join(', ')}`;
                    if (String(track.id) === String(selectedTrackId)) {
                        li.classList.add('highlight-track');  // Highlight the selected track
                    }
                    ul.appendChild(li);
                });
            } else {
                const li = document.createElement('li');
                li.style.textAlign = 'center';
                li.style.color = 'var(--text-color-secondary)';
                li.textContent = 'No tracks found for this shuffle.';
                ul.appendChild(li);
            }
            container.appendChild(ul);

            return container;
        }

        // Compare multiple shuffle orders (2 or more)
        async function handleCompareMultipleShuffles(shuffleIds, selectedTrackId) {
            shuffleOrderModalTitle.textContent = shuffleIds.length == 1 ? `` : `Comparing ${shuffleIds.length} Shuffles`;
            shuffleOrderMultiContainer.innerHTML = '<div style="text-align: center; color: var(--text-color-secondary); padding: 20px;">Loading...</div>';
            shuffleOrderError.style.display = 'none';
            shuffleOrderModal.style.display = 'block';

            try {
                const responses = await Promise.all(
                    shuffleIds.map(id => fetch(`/shuffle_order/${id}/${selectedTrackId}`))
                );
                const allData = await Promise.all(responses.map(res => res.json()));

                for (const data of allData) {
                    if (data.status === 'error') {
                        shuffleOrderMultiContainer.innerHTML = '';
                        shuffleOrderError.textContent = `Error: ${data.error}`;
                        shuffleOrderError.style.display = 'block';
                        return;
                    }
                }

                shuffleOrderMultiContainer.innerHTML = '';
                allData.forEach((data, index) => {
                    const container = createShuffleOrderContainer(shuffleIds[index], selectedTrackId, data.shuffle_order);
                    shuffleOrderMultiContainer.appendChild(container);
                });
            } catch (err) {
                console.error('Compare shuffle error:', err);
                shuffleOrderMultiContainer.innerHTML = '';
                shuffleOrderError.textContent = 'Network error fetching comparison.';
                shuffleOrderError.style.display = 'block';
            }
        }

        function updateQueueAndOverallStats(data) {
            totalUniqueTracks.textContent = data.total_unique_tracks || 0;
            totalPlaysCounted.textContent = data.total_plays_counted || 0;
            totalTracksShown.textContent = data.queue.length
            hasMoreTracks = data.has_more;
            console.log(hasMoreTracks)

            if (totalUniqueTracks.textContent == 0 && totalPlaysCounted.textContent == 0) {
                return;
            }

            // Flash the box for the number of total tracks
            trackingSummaryBox.classList.remove('flash');
            void trackingSummaryBox.offsetWidth;
            trackingSummaryBox.classList.add('flash');
        }

        function updatePlaybackInfoDisplay(info) {
            playbackItemName.textContent = info.item_name || 'N/A';
            playbackItemArtist.textContent = info.item_artist || 'N/A';
        }

        function updateContextInfoDisplay(info) {
            if (info && info.name && info.name !== 'N/A') {
                noContextMessage.style.display = 'none';
                contextDisplay.style.display = 'flex';

                contextType.textContent = info.type ? info.type.charAt(0).toUpperCase() + info.type.slice(1) : 'Unknown';
                contextName.textContent = info.name;

                if (info.image_url) {
                    contextImage.src = info.image_url;
                    contextImage.style.display = 'block';
                } else {
                    contextImage.src = '';
                    contextImage.style.display = 'none';
                }

                let ownerTotalText = '';
                if (info.owner_name) {
                    ownerTotalText += `By: ${info.owner_name}`;
                }
                if (info.total_tracks !== null && info.total_tracks !== undefined) {
                    ownerTotalText += `${ownerTotalText ? ' | ' : ''}Tracks: ${info.total_tracks}`;
                }
                contextOwnerTotal.textContent = ownerTotalText || 'N/A';

            } else {
                noContextMessage.style.display = 'block';
                contextDisplay.style.display = 'none';
                contextType.textContent = 'Unknown';
                contextName.textContent = 'N/A';
                contextOwnerTotal.textContent = '';
                contextImage.src = '';
            }
        }

        async function fetchQueueData() {
            try {
                if (!isTracking) { // Only fetch if not tracking and not in an active tracking cycle
                    const offset = currentPage * tracksPerPage;
                    const limit = tracksPerPage;
                    const url = `/queue_data?offset=${offset}&limit=${limit}&search=${encodeURIComponent(currentSearchQuery)}`;

                    const response = await fetch(url);
                    data = await response.json();

                    if (data.status === 'error') {
                        statusText.innerHTML = `Error: <strong>${data.error}</strong>`;
                        statusContainer.className = 'status status-warning';
                        if (data.error.includes("Token expired")) {
                            alert('Your Spotify session has expired. Please log in again.');
                            window.location.href = '/login';
                            return;
                        }
                    }
                }
                else {
                    // When tracking, offset is always 0 and limit is tracksPerPage
                    const url = `/queue_data?offset=0&limit=${tracksPerPage}&search=${encodeURIComponent(currentSearchQuery)}`;
                    const response = await fetch(url);
                    data = await response.json();

                    if (data.status === 'error') {
                        statusText.innerHTML = `Error: <strong>${data.error}</strong>`;
                        statusContainer.className = 'status status-warning';

                        if (data.error.includes("Token expired")) {
                            alert('Your Spotify session has expired. Please log in again.');
                            window.location.href = '/login';
                            return;
                        } else if (data.error.includes("Please start playing a song") || data.error.includes("Tracking setup incomplete") || data.error.includes("No active Spotify device found")) {
                            stopTracking(data.error);
                        }
                    }
                }
            }
            catch (error) {
                console.error('Error fetching queue data:', error);
                stopTracking("Network error or server unreachable: <strong>${error.message}</strong>");
            } finally {
                if (isTracking) {
                    setTimeout(fetchQueueData, 1000);
                }

                renderTracks(data.queue);
                updateQueueAndOverallStats(data);
                updateAllPatternsList(data.tracks_with_patterns);
                updatePaginationControls()

                // Update the playback info if we have valid data while updating the queue
                // Otherwise, it'll be updated whenever the user starts tracking
                if (data.currently_playing) {
                    updatePlaybackInfoDisplay(data.currently_playing);
                }
            }
        }

        async function startTracking() {
            if (isInitializing) return;

            isInitializing = true;
            updateToggleButtonAndStatus();

            statusText.innerHTML = 'Queue tracking is <strong>starting</strong>...';
            statusContainer.className = 'status status-inactive';

            try {
                const response = await fetch('/toggle', { method: 'POST' });
                const data = await response.json();

                isInitializing = false;

                if (data.status === 'started') {
                    isTracking = true;
                    updateToggleButtonAndStatus();
                    statusText.innerHTML = 'Queue tracking is <strong>active</strong>. We\'re automatically analyzing your Spotify queue.';
                    statusContainer.className = 'status status-active';

                    if (data.playback_info) {
                        updatePlaybackInfoDisplay(data.playback_info);
                    }
                    if (data.context_info) {
                        updateContextInfoDisplay(data.context_info);
                    }

                    document.querySelectorAll('.track-details-dropdown').forEach(dropdown => {
                        dropdown.style.display = 'none';
                        dropdown.closest('.track-item').classList.remove('active');
                        dropdown.innerHTML = '';
                    });
                    
                    fetchQueueData();
                    updatePaginationControls(true);
                } else {
                    isTracking = false;
                    updateToggleButtonAndStatus();
                    statusText.innerHTML = `Error starting tracking: <strong>${data.error}</strong>`;
                    statusContainer.className = 'status status-error';
                }
            } catch (error) {
                console.error('Error starting tracking:', error);
                isTracking = false;
                isInitializing = false;
                updateToggleButtonAndStatus();
                statusText.innerHTML = `Network error: <strong>Failed to start tracking.</strong>`;
                statusContainer.className = 'status status-error';
            }
        }

        async function stopTracking(errorMessage = "") {
            isTracking = false;
            isInitializing = false;
            
            try {
                const response = await fetch('/toggle', { method: 'POST' });
                const data = await response.json();

                if (errorMessage) {
                    statusText.innerHTML = 'Queue tracking is <strong>inactive</strong>.', errorMessage;
                    statusContainer.className = 'status status-error';
                }

                else if (data.status === 'stopped') {
                    statusText.innerHTML = 'Queue tracking is <strong>inactive</strong>. Click the button below to start tracking.';
                    statusContainer.className = 'status status-inactive';
                } else {
                    statusText.innerHTML = `Error stopping tracking cleanly: <strong>${data.error}</strong>`;
                    statusContainer.className = 'status status-error';
                }

            } catch (error) {
                console.error('Error during stopping tracking:', error);
                statusText.innerHTML = `Network error: <strong>Failed to stop tracking.</strong>`;
                statusContainer.className = 'status status-error';
            }

            fetchQueueData(); // Fetch initial data for stopped state
            updateToggleButtonAndStatus();
            updatePaginationControls(true);
        }

        function updateToggleButtonAndStatus() {
            toggleButton.classList.remove('btn-inactive', 'btn-initializing');
            if (isInitializing) {
                toggleButton.textContent = 'Please Wait...';
                toggleButton.classList.add('btn-initializing');
            } else if (isTracking) {
                toggleButton.textContent = 'Stop Tracking';
            } else {
                toggleButton.textContent = 'Start Tracking';
                toggleButton.classList.add('btn-inactive');
            }
        }

        toggleButton.addEventListener('click', () => {
            if (isInitializing) return;
            if (isTracking) {
                stopTracking();
            } else {
                startTracking();
            }
        });

        // Pagination event listeners
        prevPageBtn.addEventListener('click', () => {
            if (currentPage > 0) {
                currentPage--;
                fetchQueueData();
            }
        });

        nextPageBtn.addEventListener('click', () => {
            if (hasMoreTracks) {
                currentPage++;
                fetchQueueData();
            }
        });

        // Search input event listener (debounced)
        let searchTimeout;
        trackSearchInput.addEventListener('input', (event) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                currentSearchQuery = event.target.value;
                currentPage = 0; // Reset to first page on new search
                fetchQueueData();
            }, 300); // Debounce for 300ms
        });


        document.addEventListener('DOMContentLoaded', () => {
            isTracking = false
            isInitializing = false
            updateToggleButtonAndStatus()
            const initialContextInfo = {{ initial_context_info| tojson
        }};
        if (Object.keys(initialContextInfo).length > 0) {
            updateContextInfoDisplay(initialContextInfo);
        } else {
            updateContextInfoDisplay({});
        }

        updatePlaybackInfoDisplay({ device_name: 'N/A', is_playing: false, item_name: 'N/A', item_artist: 'N/A' });

        const initialQueueData = {{ initial_queue_data | tojson }};
        updateQueueAndOverallStats(initialQueueData);
        renderTracks(initialQueueData.queue);
        updatePaginationControls(); // Initialize pagination button states

        const hasSeenInstructions = sessionStorage.getItem('hasSeenInstructions');
        if (!hasSeenInstructions) {
            instructionModal.style.display = 'block';
        }

        closeButton.addEventListener('click', () => {
            instructionModal.style.display = 'none';
            sessionStorage.setItem('hasSeenInstructions', 'true');
        });

        modalUnderstoodButton.addEventListener('click', () => {
            instructionModal.style.display = 'none';
            sessionStorage.setItem('hasSeenInstructions', 'true');
        });

        window.addEventListener('click', (event) => {
            if (event.target == instructionModal) {
                instructionModal.style.display = 'none';
                sessionStorage.setItem('hasSeenInstructions', 'true');
            }
        });

        if (helpButton) {
            helpButton.addEventListener('click', (event) => {
                event.preventDefault();
                instructionModal.style.display = 'block';
            });
        }

        closeShuffleOrderModal.addEventListener('click', () => {
            shuffleOrderModal.style.display = 'none';
        });

        window.addEventListener('click', (event) => {
            if (event.target == shuffleOrderModal) {
                shuffleOrderModal.style.display = 'none';
            }
        });
            
        });

        {% endif %}
    </script>
</body>

</html>