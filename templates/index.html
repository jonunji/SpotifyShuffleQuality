<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify Shuffle Analyzer</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div id="instructionModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <h2>Welcome to Spotify Shuffle Analyzer!</h2>
            <p>The tool works by constantly reshuffling your active queue and recording the data.</p>
            <p>To get the most accurate information, please follow these instructions:</p>
            <ul>
                <li><strong>Keep Spotify playing:</strong> Ensure Spotify is actively playing music on a connected
                    device. This is needed for continuous calls to Spotify's servers.</li>
                <li><strong>Clear Your Queue:</strong> Checks are made to determine if the list has been shuffled. Songs
                    in the queue do not change, so this dis rupts that check.</li>
                <li><strong>Play inside a playlist/album:</strong> To see statistics about a specific playlist or album
                    you're interested in, make sure to play music from where you're interested.</li>
            </ul>
            <p>We'll then analyze how songs are added to your queue as you listen!</p>
            <button id="modal-understood-button" class="btn">Understood!</button>
        </div>
    </div>
    <div id="shuffleOrderModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeShuffleOrderModal">&times;</span>
            <h2 id="shuffleOrderModalTitle">Shuffle Order</h2>
            <ul id="shuffleOrderList" class="shuffle-order-list">
                </ul>
            <p id="shuffleOrderError" style="color: var(--error-color); text-align: center; display: none;"></p>
        </div>
    </div>
    <div id="shuffleComparisonModal" class="modal">
        <div class="modal-content">
            <span class="close-button" id="closeShuffleComparisonModal">&times;</span>
            <h2>Compare Shuffle Orders</h2>

            <div class="shuffle-order-comparison-container">
            <div class="shuffle-order-column">
                <h3>Shuffle A</h3>
                <ul id="shuffleOrderListA" class="shuffle-order-list"></ul>
            </div>
            <div class="shuffle-order-column">
                <h3>Shuffle B</h3>
                <ul id="shuffleOrderListB" class="shuffle-order-list"></ul>
            </div>
            </div>

            <p id="shuffleComparisonError" class="error-message" style="display: none;"></p>
        </div>
    </div>

    <div class="main-wrapper">
        <h1>Spotify Shuffle Analyzer</h1>

        <div class="nav-links">
            {% if logged_in %}
            <a href="/reset" class="nav-link">Reset Data</a>
            <a href="#" id="help-button" class="nav-link">Help</a>
            <a href="/logout" class="nav-link">Logout</a>
            {% endif %}
        </div>

        {% if logged_in %}
        <div id="status-container" class="status {% if running %}status-active{% else %}status-inactive{% endif %}">
            <p id="status-text">
                {% if running %}
                Queue tracking is <strong>active</strong>. We're automatically analyzing your Spotify queue.
                {% else %}
                Queue tracking is <strong>inactive</strong>. Click the button below to start tracking.
                {% endif %}
            </p>
        </div>

        <button id="toggle-tracking" class="btn {% if not running %}btn-inactive{% endif %}">
            {% if running %}
            Stop Tracking
            {% else %}
            Start Tracking
            {% endif %}
        </button>

        <div class="stats-grid">
            <div class="stat-box">
                <h3>Current Playback</h3>
                <p>Device: <span id="playback-device" class="stat-value">N/A</span></p>
                <p>Status: <span id="playback-status" class="stat-value">N/A</span></p>
                <p>Song: <span id="playback-item-name" class="stat-value">N/A</span></p>
                <p>Artist: <span id="playback-item-artist" class="stat-value">N/A</span></p>
            </div>
            <div id="tracking-summary-box" class="stat-box">
                <h3>Tracking Summary</h3>
                <p>Unique Tracks Tracked: <span id="total-unique-tracks" class="stat-value">0</span></p>
                <p>Total Plays Counted: <span id="total-plays-counted" class="stat-value">0</span></p>
            </div>
            <div class="stat-box" style="grid-column: 1 / -1;">
                <h3>Current Context (<span id="context-type" class="stat-value">Unknown</span>)</h3>
                <div id="context-display" class="context-display">
                    <img id="context-image" class="context-image" src="" alt="Context Image">
                    <div class="context-details">
                        <h3 id="context-name">N/A</h3>
                        <p id="context-owner-total"></p>
                    </div>
                </div>
                <p id="no-context-message" style="display: none;">No active context found or playing item is not from a
                    known context (e.g., local file, individual track).</p>
            </div>
        </div>

        <div id="queue-data" class="container">
            <h2>Your Most Played Tracks in Queue</h2>
            <ul class="track-list" id="track-list-container">
            </ul>
            <div class="no-tracks" id="no-tracks-message" style="display: none;">
                <p>No track data collected yet. Make sure tracking is enabled and you're using Spotify.</p>
            </div>
        </div>
        {% else %}
        <div class="container" style="text-align: center;">
            <p>Please login with your Spotify account to start tracking your queue.</p>
            <a href="/login" class="btn">Login with Spotify</a>
        </div>
        {% endif %}
    </div>

    <script>
        // Only execute if logged in
        {% if logged_in %}

        let isTracking = {{ running| tojson }};
        let continueTracking = false;
        let isInitializing = false;

        const toggleButton = document.getElementById('toggle-tracking');
        const statusContainer = document.getElementById('status-container');
        const statusText = document.getElementById('status-text');
        const trackListContainer = document.getElementById('track-list-container');
        const noTracksMessage = document.getElementById('no-tracks-message');

        // Playback Info Elements
        const playbackDevice = document.getElementById('playback-device');
        const playbackStatus = document.getElementById('playback-status');
        const playbackItemName = document.getElementById('playback-item-name');
        const playbackItemArtist = document.getElementById('playback-item-artist');

        const totalUniqueTracks = document.getElementById('total-unique-tracks');
        const totalPlaysCounted = document.getElementById('total-plays-counted');
        const trackingSummaryBox = document.getElementById('tracking-summary-box');


        // Context Info Elements
        const contextType = document.getElementById('context-type');
        const contextDisplay = document.getElementById('context-display');
        const contextImage = document.getElementById('context-image');
        const contextName = document.getElementById('context-name');
        const contextOwnerTotal = document.getElementById('context-owner-total');
        const noContextMessage = document.getElementById('no-context-message');

        // Modal elements
        const instructionModal = document.getElementById('instructionModal');
        const closeButton = document.querySelector('.close-button');
        const modalUnderstoodButton = document.getElementById('modal-understood-button');
        const helpButton = document.getElementById('help-button');

        // shuffle order modal
        const shuffleOrderModal = document.getElementById('shuffleOrderModal');
        const closeShuffleOrderModal = document.getElementById('closeShuffleOrderModal');
        const shuffleOrderList = document.getElementById('shuffleOrderList');
        const shuffleOrderError = document.getElementById('shuffleOrderError');
        const shuffleOrderModalTitle = document.getElementById('shuffleOrderModalTitle');

        const shuffleComparisonModal = document.getElementById('shuffleComparisonModal');
        const shuffleOrderListA = document.getElementById('shuffleOrderListA');
        const shuffleOrderListB = document.getElementById('shuffleOrderListB');
        const shuffleComparisonError = document.getElementById('shuffleComparisonError');

        function renderTracks(tracks) {
            trackListContainer.innerHTML = '';
            if (tracks && tracks.length > 0) {
                noTracksMessage.style.display = 'none';
                tracks.forEach(track => {
                    const trackItem = document.createElement('li');
                    trackItem.classList.add('track-item');
                    trackItem.dataset.trackId = track.id;

                    const imageUrl = track.album && track.album.images && track.album.images.length > 0
                        ? track.album.images[0].url
                        : '';
                    const artists = track.artists.map(a => a.name).join(', ') || 'Unknown Artist';

                    trackItem.innerHTML = `
                        <div class="track-main-info">
                            ${imageUrl ? `<img class="track-image" src="${imageUrl}" alt="${track.name} album art">` : '<div class="track-image"></div>'}
                            <div class="track-info">
                                <div class="track-name">${track.name}</div>
                                <div class="track-artist">${artists}</div>
                            </div>
                            <div class="track-frequency">${track.frequency}</div>
                        </div>
                        <div class="track-details-dropdown" style="display: none;">
                            </div>
                    `;
                    trackListContainer.appendChild(trackItem);
                });

                trackListContainer.querySelectorAll('.track-item').forEach(item => {
                    item.addEventListener('click', handleTrackClick);
                });

            } else {
                noTracksMessage.style.display = 'block';
                noTracksMessage.querySelector('p').textContent = "No track data collected yet. Make sure tracking is enabled and you're using Spotify.";
            }
        }

        async function handleTrackClick(event) {
            // Prevent closing if click is inside an already open dropdown
            if (event.target.closest('.track-details-dropdown') && event.currentTarget.classList.contains('active')) {
                return;
            }

            if (isTracking) {
                alert("Please stop tracking before clicking on individual songs for stats.");
                return;
            }

            const clickedTrackItem = event.currentTarget;
            const trackId = clickedTrackItem.dataset.trackId;
            const trackDetailsDropdown = clickedTrackItem.querySelector('.track-details-dropdown');

            if (!trackId || !trackDetailsDropdown) {
                console.error("No track ID or dropdown found for clicked item.");
                return;
            }

            // Close other open dropdowns
            document.querySelectorAll('.track-details-dropdown').forEach(dropdown => {
                if (dropdown !== trackDetailsDropdown && dropdown.style.display !== 'none') {
                    dropdown.style.display = 'none';
                    dropdown.closest('.track-item').classList.remove('active');
                    dropdown.innerHTML = '';
                }
            });

            // Toggle the clicked track's dropdown
            if (trackDetailsDropdown.style.display === 'none') {
                trackDetailsDropdown.style.display = 'block';
                clickedTrackItem.classList.add('active');

                trackDetailsDropdown.innerHTML = `<div style="text-align: center; color: var(--text-color-secondary); padding: 10px;">Loading stats...</div>`;

                try {
                    const response = await fetch(`/track_stats/${trackId}`);
                    const data = await response.json();

                    if (data.status === 'error') {
                        trackDetailsDropdown.innerHTML = `<div style="color: var(--error-color); padding: 10px;">Error: ${data.error}</div>`;
                        console.error("Error fetching track stats:", data.error);
                    } else {
                        updateIndividualTrackStats(data, trackDetailsDropdown, trackId);
                    }
                } catch (error) {
                    console.error('Error fetching individual track stats:', error);
                    trackDetailsDropdown.innerHTML = `<div style="color: var(--error-color); padding: 10px;">Network error loading stats.</div>`;
                }
            } else {
                trackDetailsDropdown.style.display = 'none';
                clickedTrackItem.classList.remove('active');
                trackDetailsDropdown.innerHTML = '';
            }
        }

        function updateIndividualTrackStats(stats, dropdownElement, selected_track_id) {
            const artists = stats.artists.map(a => a.name).join(', ') || 'N/A';
            const durationMinutes = Math.floor(stats.duration_ms / 60000);
            const seconds = ((stats.duration_ms % 60000) / 1000).toFixed(0);
            const formattedDuration = `${durationMinutes}:${(seconds < 10 ? '0' : '')}${seconds}`;
            const genres = stats.artist_genres && stats.artist_genres.length > 0 ? stats.artist_genres.join(', ') : 'N/A';
            const shuffleChance = stats.shuffle_chance_percent ? stats.shuffle_chance_percent.toFixed(2) : '0.00';
            const popularity = stats.popularity || 0;

            let artistBreakdownHtml = '';
            if (typeof stats.songs_by_same_artists === 'object' && Object.keys(stats.songs_by_same_artists).length > 0) {
                const artistListItems = Object.keys(stats.songs_by_same_artists).map(artistId => {
                    const tracksForArtist = stats.songs_by_same_artists[artistId];

                    if (!Array.isArray(tracksForArtist) || tracksForArtist.length === 0) {
                        return '';
                    }

                    const artistName = tracksForArtist[0].artists.find(a => String(a.id) === String(artistId))?.name || 'Unknown Artist';

                    const trackItems = tracksForArtist.map(track => {
                        return `<li>${track.name} (${track.frequency} plays)</li>`;
                    }).join('');

                    return `
                        <li>
                            <strong>${artistName}</strong> (${tracksForArtist.length} track${tracksForArtist.length !== 1 ? 's' : ''}):
                            <ul class="nested-stat-list">
                                ${trackItems}
                            </ul>
                        </li>
                    `;
                }).join('');

                artistBreakdownHtml = `
                    <div class="stat-row" style="flex-direction: column; align-items: flex-start;">
                        <span class="stat-label" style="margin-bottom: 5px;">Breakdown by Matching Artists:</span>
                        <ul class="stat-list">
                            ${artistListItems}
                        </ul>
                    </div>`;
            } else {
                artistBreakdownHtml = `
                    <div class="stat-row">
                        <span class="stat-label">Songs by Matching Artists:</span>
                        <span class="stat-value">0</span>
                    </div>`;
            }

            let genreMatchHtml = '';
            if (stats.songs_matching_genre && stats.songs_matching_genre.length > 0) {
                genreMatchHtml = `
                    <div class="stat-row" style="flex-direction: column; align-items: flex-start;">
                        <span class="stat-label" style="margin-bottom: 5px;">Songs Matching Genres:</span>
                        <ul class="stat-list">
                            ${stats.songs_matching_genre.map(t => {
                                const artists = t.artists.map(a => a.name).join(', ');
                                return `<li><strong>${artists}</strong>: ${t.name} (${t.frequency} plays)</li>`;
                            }).join('')}
                        </ul>
                    </div>`;
            } else {
                genreMatchHtml = `
                    <div class="stat-row">
                        <span class="stat-label">Songs Matching Genres:</span>
                        <span class="stat-value">0</span>
                    </div>`;
            }

            let patternsHtml = '';
            if (stats.patterns && stats.patterns.length > 0) {
                const uniquePatternsWithCounts = stats.patterns;

                const patternColumnsHtml = uniquePatternsWithCounts.map((patternData, index) => {
                    const patternTracks = patternData.pattern;
                    const patternCount = patternData.count;

                    if (!Array.isArray(patternTracks) || patternTracks.length < 2) {
                        return '';
                    }

                    const trackListItems = patternTracks.map(track_obj => {
                        // Crucial for bolding: Ensure comparison is robust
                        const isSelectedTrackInPattern = String(track_obj.id) === String(selected_track_id);
                        const classAttr = isSelectedTrackInPattern ? ' class="selected-track-in-pattern"' : '';
                        return `<li${classAttr}>${track_obj.name}</li>`;
                    }).join('');

                    return `
                        <div class="pattern-column">
                            <h4>Pattern ${index + 1} <span style="font-size: 0.8em; color: var(--text-color-secondary);">(${patternCount} time${patternCount !== 1 ? 's' : ''})</span></h4>
                            <ul>
                                ${trackListItems}
                            </ul>
                        </div>
                    `;
                }).filter(Boolean).join('');

                patternsHtml = `
                    <div class="stat-row" style="flex-direction: column; align-items: flex-start; margin-top: 15px;">
                        <span class="stat-label" style="margin-bottom: 5px;">Unique Shuffle Patterns Found:</span>
                        <div class="pattern-container">
                            ${patternColumnsHtml}
                        </div>
                    </div>`;
            } else {
                patternsHtml = `
                    <div class="stat-row" style="margin-top: 15px;">
                        <span class="stat-label">Unique Shuffle Patterns Found:</span>
                        <span class="stat-value">None</span>
                    </div>`;
            }

            shuffleOrderHtml = `
                <div class="shuffle-control-row">
                ${stats.shuffle_ids.length === 1 ? `
                    <select class="shuffle-id-select" id="shuffleIdSelect-${stats.id}">
                    <option value="">Select Shuffle ID</option>
                    <option value="${stats.shuffle_ids[0]}">${stats.shuffle_ids[0]}</option>
                    </select>
                    <button class="btn view-order-btn" data-track-id="${stats.id}" style="display: none;">View Order</button>
                ` : `
                    <div class="shuffle-pair">
                    <select class="shuffle-id-select" id="compareShuffleIdSelectA-${stats.id}">
                        <option value="">Shuffle A</option>
                        ${stats.shuffle_ids.map(id => `<option value="${id}">${id}</option>`).join('')}
                    </select>
                    <select class="shuffle-id-select" id="compareShuffleIdSelectB-${stats.id}">
                        <option value="">Shuffle B</option>
                        ${stats.shuffle_ids.map(id => `<option value="${id}">${id}</option>`).join('')}
                    </select>
                    </div>
                    <button class="btn view-order-btn" data-track-id="${stats.id}" style="display: none;">View Order</button>
                    <button class="btn view-compare-order-btn" data-track-id="${stats.id}" style="display: none;">Compare Orders</button>
                `}
                </div>
                `;

            dropdownElement.innerHTML = `
                <div class="track-details-content">
                    <div class="stat-row">
                        <span class="stat-label">Plays in Queue:</span>
                        <span class="stat-value">${stats.frequency}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Approx. Shuffle Chance:</span>
                        <span class="stat-value">${shuffleChance}%</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Album:</span>
                        <span class="stat-value">${stats.album_name}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Duration:</span>
                        <span class="stat-value">${formattedDuration}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Popularity:</span>
                        <span class="stat-value">${popularity}%</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Genres (of artists):</span>
                        <span class="stat-value">${genres}</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Total Plays by Matching Artists:</span>
                        <span class="stat-value">${stats.total_plays_by_same_artists}</span>
                    </div>
                    ${artistBreakdownHtml}
                    ${genreMatchHtml}
                    ${patternsHtml}
                    ${shuffleOrderHtml}
                </div>
            `;

            const viewOrderBtn = dropdownElement.querySelector('.view-order-btn');
            const compareBtn = dropdownElement.querySelector('.view-compare-order-btn');

            if (stats.shuffle_ids.length === 1) {
            const select = dropdownElement.querySelector(`#shuffleIdSelect-${stats.id}`);
            select.addEventListener('change', (e) => {
                viewOrderBtn.dataset.shuffleId = e.target.value;
                viewOrderBtn.dataset.trackId = selected_track_id;
                viewOrderBtn.style.display = e.target.value ? 'block' : 'none';
            });
            viewOrderBtn.addEventListener('click', handleViewOrderClick);
            } else {
            const selectA = dropdownElement.querySelector(`#compareShuffleIdSelectA-${stats.id}`);
            const selectB = dropdownElement.querySelector(`#compareShuffleIdSelectB-${stats.id}`);

            function updateButtons() {
                const valA = selectA.value;
                const valB = selectB.value;
                compareBtn.dataset.trackId = selected_track_id;
                viewOrderBtn.dataset.trackId = selected_track_id;

                if (valA && valB) {
                    compareBtn.dataset.shuffleIdA = valA;
                    compareBtn.dataset.shuffleIdB = valB;
                    compareBtn.style.display = 'block';
                    viewOrderBtn.style.display = 'none'; // Hide single view button
                } else if (valA) { // Only A is selected
                    viewOrderBtn.dataset.shuffleId = valA;
                    viewOrderBtn.style.display = 'block';
                    compareBtn.style.display = 'none'; // Hide compare button
                } else if (valB) { // Only B is selected
                    viewOrderBtn.dataset.shuffleId = valB;
                    viewOrderBtn.style.display = 'block';
                    compareBtn.style.display = 'none'; // Hide compare button
                } else {
                    viewOrderBtn.style.display = 'none';
                    compareBtn.style.display = 'none';
                }
            }

            selectA.addEventListener('change', updateButtons);
            selectB.addEventListener('change', updateButtons);

            viewOrderBtn.addEventListener('click', handleViewOrderClick);
            compareBtn.addEventListener('click', handleViewCompareOrderClick);
            }
        }

        // New reusable function to display a single shuffle order modal
        async function displayShuffleOrderModal(shuffleId, selectedTrackId, title = `Shuffle Order (ID: ${shuffleId})`) {
            console.log(shuffleId)
            console.log(selectedTrackId)
            if (!shuffleId) {
                console.error("No shuffle ID provided to displayShuffleOrderModal.");
                shuffleOrderError.textContent = 'Error: No Shuffle ID provided.';
                shuffleOrderError.style.display = 'block';
                shuffleOrderModal.style.display = 'block'; // Still show modal with error
                shuffleOrderList.innerHTML = '';
                return;
            }

            shuffleOrderModalTitle.textContent = title;
            shuffleOrderList.innerHTML = '<div style="text-align: center; color: var(--text-color-secondary); padding: 20px;">Loading...</div>';
            shuffleOrderError.style.display = 'none';
            shuffleOrderModal.style.display = 'block';

            try {
                const response = await fetch(`/shuffle_order/${shuffleId}/${selectedTrackId}`);
                const data = await response.json();

                if (data.status === 'error') {
                    shuffleOrderList.innerHTML = '';
                    shuffleOrderError.textContent = `Error: ${data.error}`;
                    shuffleOrderError.style.display = 'block';
                } else {
                    shuffleOrderList.innerHTML = ''; // Clear loading message
                    if (data.shuffle_order && data.shuffle_order.length > 0) {
                        data.shuffle_order.forEach(track => {
                            const listItem = document.createElement('li');
                            listItem.textContent = `${track.name} - ${track.artists.map(a => a.name).join(', ')}`;
                            // Apply the highlight-track class if this is the selected track
                            if (String(track.id) === String(selectedTrackId)) {
                                listItem.classList.add('highlight-track');
                            }
                            shuffleOrderList.appendChild(listItem);
                        });
                    } else {
                        shuffleOrderList.innerHTML = '<li style="text-align: center; color: var(--text-color-secondary);">No tracks found for this shuffle ID.</li>';
                    }
                }
            } catch (error) {
                console.error('Error fetching shuffle order:', error);
                shuffleOrderList.innerHTML = '';
                shuffleOrderError.textContent = 'Network error fetching shuffle order.';
                shuffleOrderError.style.display = 'block';
            }
        }

        async function handleViewOrderClick(event) {
            const shuffleId = event.currentTarget.dataset.shuffleId;
            const selectedTrackId = event.currentTarget.dataset.trackId;
            console.log('handleViewOrderClick called. shuffleId:', shuffleId, 'selectedTrackId:', selectedTrackId);
            displayShuffleOrderModal(shuffleId, selectedTrackId);
        }

        async function handleViewCompareOrderClick(event) {
            const shuffleIdA = event.currentTarget.dataset.shuffleIdA;
            const shuffleIdB = event.currentTarget.dataset.shuffleIdB;
            const selectedTrackId = event.currentTarget.dataset.trackId;

            console.log(selectedTrackId)

            // If only one is selected, default to showing the single shuffle order modal
            if (!shuffleIdA && shuffleIdB) {
                displayShuffleOrderModal(shuffleIdB, selectedTrackId, `Shuffle Order (ID: ${shuffleIdB})`);
                return;
            } else if (shuffleIdA && !shuffleIdB) {
                displayShuffleOrderModal(shuffleIdA, selectedTrackId, `Shuffle Order (ID: ${shuffleIdA})`);
                return;
            } else if (!shuffleIdA && !shuffleIdB) {
                // This case means neither A nor B is selected, button should ideally be hidden
                console.warn("Neither Shuffle A nor Shuffle B selected for comparison.");
                return;
            }

            // Proceed with full comparison modal if both IDs are selected
            shuffleOrderListA.innerHTML = '<div style="text-align: center; color: var(--text-color-secondary); padding: 20px;">Loading...</div>';
            shuffleOrderListB.innerHTML = '<div style="text-align: center; color: var(--text-color-secondary); padding: 20px;">Loading...</div>';
            shuffleComparisonError.style.display = 'none';
            shuffleComparisonModal.style.display = 'block';

            try {
                const [responseA, responseB] = await Promise.all([
                    fetch(`/shuffle_order/${shuffleIdA}/${selectedTrackId}`),
                    fetch(`/shuffle_order/${shuffleIdB}/${selectedTrackId}`)
                ]);

                const dataA = await responseA.json();
                const dataB = await responseB.json();

                if (dataA.status === 'error' || dataB.status === 'error') {
                    shuffleOrderListA.innerHTML = '';
                    shuffleOrderListB.innerHTML = '';
                    shuffleComparisonError.textContent = `Error loading one or both shuffle orders: ${dataA.error || ''} ${dataB.error || ''}`;
                    shuffleComparisonError.style.display = 'block';
                    return;
                }

                // Render Shuffle A
                shuffleOrderListA.innerHTML = '';
                if (dataA.shuffle_order?.length > 0) {
                    dataA.shuffle_order.forEach(track => {
                        const listItem = document.createElement('li');
                        listItem.textContent = `${track.name} - ${track.artists.map(a => a.name).join(', ')}`;
                        if (String(track.id) === String(selectedTrackId)) {
                            listItem.classList.add('highlight-track');
                        }
                        shuffleOrderListA.appendChild(listItem);
                    });
                } else {
                    shuffleOrderListA.innerHTML = '<li style="text-align: center; color: var(--text-color-secondary);">No tracks found for Shuffle A.</li>';
                }

                // Render Shuffle B
                shuffleOrderListB.innerHTML = '';
                if (dataB.shuffle_order?.length > 0) {
                    dataB.shuffle_order.forEach(track => {
                        const listItem = document.createElement('li');
                        listItem.textContent = `${track.name} - ${track.artists.map(a => a.name).join(', ')}`;
                        if (String(track.id) === String(selectedTrackId)) {
                            listItem.classList.add('highlight-track');
                        }
                        shuffleOrderListB.appendChild(listItem);
                    });
                } else {
                    shuffleOrderListB.innerHTML = '<li style="text-align: center; color: var(--text-color-secondary);">No tracks found for Shuffle B.</li>';
                }

            } catch (error) {
                console.error('Error fetching shuffle comparison data:', error);
                shuffleOrderListA.innerHTML = '';
                shuffleOrderListB.innerHTML = '';
                shuffleComparisonError.textContent = 'Network error fetching comparison data.';
                shuffleComparisonError.style.display = 'block';
            }
        }

        function updateQueueAndOverallStats(data) {
            totalUniqueTracks.textContent = data.total_unique_tracks || 0;
            totalPlaysCounted.textContent = data.total_plays_counted || 0;

            if (totalUniqueTracks.textContent == 0 && totalPlaysCounted.textContent == 0) {
                return;
            }

            trackingSummaryBox.classList.remove('flash');
            void trackingSummaryBox.offsetWidth;
            trackingSummaryBox.classList.add('flash');
        }

        function updatePlaybackInfoDisplay(info) {
            playbackDevice.textContent = info.device_name || 'N/A';
            playbackStatus.textContent = info.is_playing ? 'Playing' : 'Paused';
            playbackItemName.textContent = info.item_name || 'N/A';
            playbackItemArtist.textContent = info.item_artist || 'N/A';
        }

        function updateContextInfoDisplay(info) {
            if (info && info.name && info.name !== 'N/A') {
                noContextMessage.style.display = 'none';
                contextDisplay.style.display = 'flex';

                contextType.textContent = info.type ? info.type.charAt(0).toUpperCase() + info.type.slice(1) : 'Unknown';
                contextName.textContent = info.name;

                if (info.image_url) {
                    contextImage.src = info.image_url;
                    contextImage.style.display = 'block';
                } else {
                    contextImage.src = '';
                    contextImage.style.display = 'none';
                }

                let ownerTotalText = '';
                if (info.owner_name) {
                    ownerTotalText += `By: ${info.owner_name}`;
                }
                if (info.total_tracks !== null && info.total_tracks !== undefined) {
                    ownerTotalText += `${ownerTotalText ? ' | ' : ''}Tracks: ${info.total_tracks}`;
                }
                contextOwnerTotal.textContent = ownerTotalText || 'N/A';

            } else {
                noContextMessage.style.display = 'block';
                contextDisplay.style.display = 'none';
                contextType.textContent = 'Unknown';
                contextName.textContent = 'N/A';
                contextOwnerTotal.textContent = '';
                contextImage.src = '';
            }
        }

        async function fetchQueueData() {
            if (!continueTracking) {
                return;
            }

            try {
                const response = await fetch('/queue_data');
                const data = await response.json();

                if (data.status === 'error') {
                    statusText.innerHTML = `Error: <strong>${data.error}</strong>`;
                    statusContainer.className = 'status status-warning';

                    if (data.error.includes("Token expired")) {
                        alert('Your Spotify session has expired. Please log in again.');
                        window.location.href = '/login';
                        return;
                    } else if (data.error.includes("Please start playing a song") || data.error.includes("Tracking setup incomplete") || data.error.includes("No active Spotify device found")) {
                        stopTracking(false);
                    }
                } else if (data.status === 'paused') {
                    statusText.innerHTML = `Queue tracking is <strong>inactive</strong>. Playback paused or no active device/song.`;
                    statusContainer.className = 'status status-inactive';
                    stopTracking(false);
                } else {
                    renderTracks(data.queue);
                    updateQueueAndOverallStats(data);
                }

            } catch (error) {
                console.error('Error fetching queue data:', error);
                statusText.innerHTML = `Network error or server unreachable: <strong>${error.message}</strong>`;
                statusContainer.className = 'status status-inactive';
                stopTracking(false);
            } finally {
                if (continueTracking) {
                    setTimeout(fetchQueueData, 1000);
                }
            }
        }

        async function startTracking() {
            if (isInitializing) return;

            isInitializing = true;
            updateToggleButtonAndStatus();

            try {
                const response = await fetch('/toggle', { method: 'POST' });
                const data = await response.json();

                if (data.status === 'started') {
                    isTracking = true;
                    isInitializing = false;
                    updateToggleButtonAndStatus();
                    statusText.innerHTML = 'Queue tracking is <strong>active</strong>. We\'re automatically analyzing your Spotify queue.';
                    statusContainer.className = 'status status-active';

                    if (data.playback_info) {
                        updatePlaybackInfoDisplay(data.playback_info);
                    }
                    if (data.context_info) {
                        updateContextInfoDisplay(data.context_info);
                    }

                    document.querySelectorAll('.track-details-dropdown').forEach(dropdown => {
                        dropdown.style.display = 'none';
                        dropdown.closest('.track-item').classList.remove('active');
                        dropdown.innerHTML = '';
                    });

                    continueTracking = true;
                    fetchQueueData();
                } else {
                    isTracking = false;
                    isInitializing = false;
                    updateToggleButtonAndStatus();
                    statusText.innerHTML = `Error starting tracking: <strong>${data.error}</strong>`;
                    statusContainer.className = 'status status-warning';
                }
            } catch (error) {
                console.error('Error starting tracking:', error);
                isTracking = false;
                isInitializing = false;
                updateToggleButtonAndStatus();
                statusText.innerHTML = `Network error: <strong>Failed to start tracking.</strong>`;
                statusContainer.className = 'status status-warning';
            }
        }

        async function stopTracking(sendToggleRequest = true) {
            continueTracking = false;
            isInitializing = false;

            if (sendToggleRequest) {
                try {
                    const response = await fetch('/toggle', { method: 'POST' });
                    const data = await response.json();
                    if (data.status === 'stopped') {
                        statusText.innerHTML = 'Queue tracking is <strong>inactive</strong>. Click the button below to start tracking.';
                        statusContainer.className = 'status status-inactive';
                    } else {
                        statusText.innerHTML = `Error stopping tracking cleanly: <strong>${data.error}</strong>`;
                        statusContainer.className = 'status status-inactive';
                    }
                } catch (error) {
                    console.error('Error during stopping tracking:', error);
                    statusText.innerHTML = `Network error: <strong>Failed to stop tracking.</strong>`;
                    statusContainer.className = 'status status-inactive';
                }
            } else {
                statusText.innerHTML = 'Queue tracking is <strong>inactive</strong>. Playback paused or no active device/song.';
                statusContainer.className = 'status status-warning';
            }

            isTracking = false;
            updateToggleButtonAndStatus();
        }

        function updateToggleButtonAndStatus() {
            toggleButton.classList.remove('btn-inactive', 'btn-initializing');
            if (isInitializing) {
                toggleButton.textContent = 'Please Wait...';
                toggleButton.classList.add('btn-initializing');
            } else if (isTracking) {
                toggleButton.textContent = 'Stop Tracking';
            } else {
                toggleButton.textContent = 'Start Tracking';
                toggleButton.classList.add('btn-inactive');
            }
        }

        toggleButton.addEventListener('click', () => {
            if (isInitializing) return;
            if (isTracking) {
                stopTracking();
            } else {
                startTracking();
            }
        });

        document.addEventListener('DOMContentLoaded', () => {
            updateToggleButtonAndStatus();
            const initialContextInfo = {{ initial_context_info| tojson }};
            if (Object.keys(initialContextInfo).length > 0) {
                updateContextInfoDisplay(initialContextInfo);
            } else {
                updateContextInfoDisplay({});
            }

            updatePlaybackInfoDisplay({ device_name: 'N/A', is_playing: false, item_name: 'N/A', item_artist: 'N/A' });
            updateQueueAndOverallStats({});
            renderTracks([]);

            const hasSeenInstructions = sessionStorage.getItem('hasSeenInstructions');
            if (!hasSeenInstructions) {
                instructionModal.style.display = 'block';
            }

            closeButton.addEventListener('click', () => {
                instructionModal.style.display = 'none';
                sessionStorage.setItem('hasSeenInstructions', 'true');
            });

            modalUnderstoodButton.addEventListener('click', () => {
                instructionModal.style.display = 'none';
                sessionStorage.setItem('hasSeenInstructions', 'true');
            });

            window.addEventListener('click', (event) => {
                if (event.target == instructionModal) {
                    instructionModal.style.display = 'none';
                    sessionStorage.setItem('hasSeenInstructions', 'true');
                }
            });

            if (helpButton) {
                helpButton.addEventListener('click', (event) => {
                    event.preventDefault();
                    instructionModal.style.display = 'block';
                });
            }

            closeShuffleOrderModal.addEventListener('click', () => {
                shuffleOrderModal.style.display = 'none';
            });

            window.addEventListener('click', (event) => {
                if (event.target == shuffleOrderModal) {
                    shuffleOrderModal.style.display = 'none';
                }
            });

            const closeShuffleComparisonModal = document.getElementById('closeShuffleComparisonModal');
            if (closeShuffleComparisonModal) {
            closeShuffleComparisonModal.addEventListener('click', () => {
                shuffleComparisonModal.style.display = 'none';
            });
            }

            window.addEventListener('click', (event) => {
                if (event.target == shuffleComparisonModal) {
                    shuffleComparisonModal.style.display = 'none';
                }
            });
            
        });

        {% endif %}
    </script>
</body>

</html>